---
layout: post
title:  "软件设计哲学"
date:   2020-04-09 23:28:36 +0800
categories: CS
---

# 软件设计哲学

## 复杂性

### 复杂性的病症

- 变化放大：在多个地方修改；（烦人）
- 认知负载：程序员完成任务需要知道多少；（增加变更的成本）
- 不知道你不知道：要完成任务不明确要修改哪快代码，或开发人员必须具备哪些信息才能成功完成任务。（最麻烦）

> 好的系统设计最重要的目标之一是： `obvious`。

### 复杂性的成因

- depencies：当一段代码不能独立的理解和修改就形成了；
- obscurity：当重要的信息不明确就形成了。比如 `time` 这种变量名。

> 复杂性是渐增的。

## 战术与战略编程

- 战术：着眼于使功能尽快运行；
- 战略：花时间产生简洁架构以及修复问题。

### 战术编程

- 主要是跑起来：**新需求** 以及 **bug 修复**；
- 花不了太多的功夫做好设计，只想尽快干完；
- 增加复杂性 just ok。

> 这样就造成了复杂性，**注意是渐增的**。

战术编程注重快速完成任务。因此会寻找 `quick patch` 来处理遇到的问题。进而创造了复杂性，进而需要更多的 `patch`。而这最终只会走上战术编程这一唯一道路。

**战术龙卷风**是一位多产的程序员，他抽出代码的速度比其他人快得多，但完全以战术方式工作。而其他程序员得给**战术龙卷风**擦屁股，更加凸显战术龙卷风的吊。

### 战略编程

- 第一步：**Working Code Isn't Enough**；
- 为了完成当前任务增加不必要的复杂性是不可接受的；
- 首要任务：产生 `great design`；
- 需要投资思维：相对于最快的完成项目，不如花时间优化设计。
    - 多尝试几种设计模式，直到找到最简洁的；
    - 多写文档；
    - 之前的设计模式可能有问题，花时间去修复而不是不管或 `patch`。

> 10% - 20% 的时间用来投资。


## 模块应该 Deep

模块化设计的目标是模块间依赖最小化。

每个模块分为两部分：

- 接口：包含了在另一个模块的开发者使用这个模块的需要直到的所有内容。（What）
- 实现：接口许诺的代码实现。（How it dose it）

> 任何**有接口和实现的代码单元**都是一个**模块**。

> `OO` 语言中一个 `class` 就是一个模块；类中的方法，`非OO` 语言中的**方法**都可以认为是模块；高等级的子系统以及服务也是模块，它们的接口可能是 `内核调用` 或者 `HTTP 请求`。

> 最好的模块化是那些**接口比实现简单的多的**。1. **简单的接口**最大程度地减少模块施加在系统其余部分上的复杂性；2. 如果一个模块修改不需要修改接口，就不会影响其他模块。

### 接口

包含两种类型的信息：

- formal: `public` 方法签名，`public field` 类型和名称；
- informal: 只存在于注释中，还不一定保证完整和精准。

### 抽象

是一个实体的一个简单试图，消除了不必要的细节。

- 不能暴露不重要的细节；
- 不能隐藏较重要的细节。

### 深模块

模块深度可以是一种 `cost` vs. `benefit` 的思想。

- benefit: 提供的功能性；
- cost: 对于复杂性来说就是接口。

> 接口应该使常见情况越简单越好。

## 信息的隐藏（和泄漏）

### 信息隐藏

达到深模块的最重要的技术是**信息隐藏**。基本思想是每个模块应该**封装一些知识**（代表**设计决策**）。这些知识**隐藏在实现中而不是表现在接口中**。e.g.
- B树如何保存信息，如何高效访问；
- 如何实现 `TCP` 网络协议；
- 如何在多线程处理器调度线程。

信息隐藏从两方面减少了复杂性：
- 简化了模块的接口。减少了模块使用者的认知负担；
- 改进系统更加简单。更改实现不影响接口的调用。

> 信息隐藏**不等同于**`private`。因为 `private` 字段也能通过 `public` 方法暴露出去。

### 信息泄漏

当一个**设计决策**（`design decision`）反映在多个模块中时，就会发生信息泄漏。这样会创建**模块间的依赖**：`design decision` 的修改都会引起相关模块的修改。

如果**信息表现在模块的接口上**，这个信息就泄漏了。

> 当然信息泄漏也放生在那些没在接口上的信息。例如：两个类对一种文件格式的文件进行读写。虽然这个文件格式没有出现在接口上，但是修改这个文件格式就需要修改这两个类。

> 上面后门式泄漏更有害但也更不明显。


**信息泄漏**是软件设计中最重要的 `red flag`。

> 作为软件设计师，您可以学习的最佳技能之一是**对信息泄漏的高度敏感**。

**e.g.** 如果遇到在类间的信息泄漏，就应该问自己：如何重新组织这些类使得这个信息只影响一个类。

可以考虑两种方式：
- 类合并；
- 抽象出一个新的类。

### 时间分解

造成**信息泄漏**的最常见的原因是**时间分解**。

在时间分解中，系统的结构对应于操作将发生的时间顺序。

**e.g.** 一个程序对于一种文件格式的读、写、修改在时间解构下可能分为 3 个类。所有的这些类都需要知道文件格式的知识，造成了信息泄漏。

## 通用模块都 `Deeper`

设计一个新的模块时需要考虑是使用 `general-purpose` 还是 `special-purpose` 方式来实现它。

### somewhat general-purpose

`class` 的功能应该表现当前的需求，而接口不是。**接口应该能能满足多种需求而足够通用**。接口对于当前的需求也应该容易使用。

e.g. `editor` 中删除文本

```c
// backspace 键
void backspace(Cursor cursor);
// delete 键
void delete(Cursor cursor);
// 选择后删除
void deleteSelection(Selection selection);
```

这些特殊化只为接口用户提供了较少的利益，还增加了认知负担。这样到头来，接口会有大量的浅层方法。有许多方法只会被调用一次。

而应该使用较通用的 `API`。

```c
void insert(Position position, String newText);
void delete(Position start, Position end);
Position changePosition(Position position, int numChars);
```

1. 这里使用了 `Position` 代替 `Cursor`，更加通用；

`backspace` 可以实现为： `text.delete(text.changePosition(cursor, -1), cursor);`

假如提供了 `backspace`，用户得到这个文件阅读文档。

```c
Position findNext(Position start, String string);
```

### 通用性可以更好地隐藏信息


软件设计最重要的元素之一就是**确定谁需要知道什么以及何时知道**。**当细节很重要时，最好使它们明确且尽可能明显**，例如修订的 `Backspace` 操作实现。将这些信息隐藏在界面后面只会产生晦涩感。

### 三省吾身

- 能满足当前需求的最简单的接口是什么；
- 这个方法在多少情况下回被使用；
- 当前需求下这个 `API` 用的简单么。

## 不同层，不同抽象

软件系统由多个层组成。较高的层使用较低层提供的设施。良好设计的系统，每层提供不同的抽象。

**如果系统包含了相邻层由这相似的抽象。表明类分解存在问题。**

当相邻层由相似的抽象，该问题通常以 `pass-through methods` 的方式展现。

`pass-through methods`：那些方法签名和调用的方法签名类似，除了调用其他方法基本不做啥。

- 这类方法创建了类与类的依赖，被调用的方法签名变更，调用的方法签名也要变更；
- 没有增加功能性，只有最底层的方法有功能性。


这类方法表明：`class` 之间责任划分混乱。**一个类提供接口，但是用另一个类却实现接口**。这通常是一个坏主意。

> 功能的接口通常应该和功能的实现在同一个 `class`。

当遇到 `pass-through methods` 问自己： “这些类分别负责哪些功能和抽象？”你会发现**类的责任有重叠**。

> 解决方案：重构类，以使每个类都有各自不同且连贯的职责。

![7-1]({{ site.url }}/assets/imgs/system_design/sd-7-1.png)

- b: 将低层暴露给上层；
- c: 重新分配两个类的功能；
- d: 合并两个类。


### 什么时候接口重复是 OK 的？


- `dispatcher`；
- 接口有多个实现；

### 装饰器： `BufferedInputStream`

- 动机：将类的特殊目的拓展与 `more generic core` 分开。
- 创建装饰器类需要考虑的：
    - 能直接在类上直接添加功能而不创建装饰器类？
    - 能否将特殊的需求与普通需求合并？
    - 新功能在现有的装饰器上实现？
    - 新功能是否真的需要包装现有功能？

### 接口 vs. 实现

类的**接口通常应与其实现不同**：内部使用的表示形式应与接口中出现的抽象不同。如果两者具有相似的抽象，则该类可能不是很深。


### 传递变量

变量通过一长串方法传递。如果要添加一个变量，就必须顺着调用链都加上。

- 现有的变量里面包括；
- 存到全局变量；
- context object。



