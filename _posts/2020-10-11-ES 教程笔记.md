---
layout: post
title:  "ES 教程记录"
date:   2020-10-11 11:15:50 +0800
categories: ElasticSearch
---


# ES

## 入门操作

### 集群创建索引

3 节点的 `ES` 集群。

创建 3 分片，1 副本的索引。
```shell
curl --request PUT \
  --url http://localhost:9200/blogs \
  --header 'content-type: application/json' \
  --data '{
   "settings" : {
      "number_of_shards" : 3,
      "number_of_replicas" : 1
   }
}'
```

![blog-2]({{ site.url }}/assets/imgs/es/blog-2.png)

然后更新副本数量为 3。

```shell
curl --request PUT \
  --url http://localhost:9200/blogs/_settings \
  --header 'content-type: application/json' \
  --data '{
   "number_of_replicas" : 2
}'
```

![blog-3]({{ site.url }}/assets/imgs/es/blog-3.png)


自动生成的 `ID` 为 `Base64` 最多 20 个字符的 `GUID` 字符串。

文档不可变，不能修改它们。使用相同的 `API` 进行替换：
- `_version` 会变；
- `created` 也变为 `false`；
- 旧文档标记为删除，增加全新的文档。旧文档在后台被处理。

### `bulk` 批量加入文档

```shell
curl -H "Content-Type: application/json" -XPOST "localhost:9200/<index-name>/_bulk?pretty&refresh" --data-binary "@data.json"
```

> 文档数量最好 `1000 - 5000`, 总大小 `5MB - 15MB`。


### basic search

`bank` 格式如下：

```json
{
    "account_number": 568,
    "balance": 36628,
    "firstname": "Lesa",
    "lastname": "Maynard",
    "age": 29,
    "gender": "F",
    "address": "295 Whitty Lane",
    "employer": "Coash",
    "email": "lesamaynard@coash.com",
    "city": "Broadlands",
    "state": "VT"
}
```

**查找所有**

```shell
curl --request GET \
  --url http://localhost:9200/bank/_search \
  --header 'content-type: application/json' \
  --data '{
	"query": {
		"match_all": {}
	},
	"sort": [
		{ "account_number": "asc" }
	],
	"from": 10,
	"size": 10
}'
```

- 如果没有 `from` 和 `size` 返回的是前 10 条。

返回样例：

```json
{
  "took" : 63,
  "timed_out" : false,
  // 查询的分片以及各种情况
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
        "value": 1000,
        "relation": "eq"
    },
    "max_score" : null,
    "hits" : [ {
      "_index" : "bank",
      "_type" : "_doc",
      "_id" : "0",
      "sort": [0],
      "_score" : null,
      "_source" : {"account_number":0,"balance":16623,"firstname":"Bradshaw","lastname":"Mckenzie","age":29,"gender":"F"}
    }, {
      "_index" : "bank",
      "_type" : "_doc",
      "_id" : "1",
      "sort": [1],
      "_score" : null,
      "_source" : {"account_number":1,"balance":39225,"firstname":"Amber","lastname":"Duke","age":32,"gender":"M"}
    } ]
  }
}
```

**匹配查询**

```shell
curl --request GET \
  --url http://localhost:9200/bank/_search \
  --header 'content-type: application/json' \
  --data '{
	"query": {
		"match": {"address": "mill lane"}
	}
}'
```

- 这样会查询 `address` 包含 `mill` **或** `lane` 的；
- 要精确查包含 `mill lane` 的就要吧 `match` --> `match_phrase`。

```json
{
  "query": {
    "bool": {
      "must": [
        { "match": { "age": "40" } }
      ],
      // 不匹配的
      "must_not": [
        { "match": { "state": "ID" } }
      ]
    }
  }
}
```

- 还有 `should`；
  - `must` 和 `should` 会影响匹配文档的 `score`；
  - `must_not` 当作 `filter` 来用，不影响 `score`。


```json
{
  "query": {
    "bool": {
      "must": { "match_all": {} },
      "filter": {
        "range": {
          "balance": {
            "gte": 20000,
            "lte": 30000
          }
        }
      }
    }
  }
}
```

**聚合**

这里按照 `stats` 聚合，返回 `balance` 的**平均值**以及**聚合的文档数量**并按照 `balance` 倒序。

```json
{
  "size": 0,
  "aggs": {
    "group_by_state": {
      "terms": {
        // state 类型为 text
        "field": "state.keyword",
		"order": {
          "average_balance": "desc"
        }
      },
      "aggs": {
        "average_balance": {
          "avg": {
            "field": "balance"
          }
        }
      }
    }
  }
}
```

## index 模型

**静态设置**

- `index.number_of_shards`: **主分片**的数量，只能在创建时设置；
- `index.number_of_routing_shards`: 分割 `index` 的路由分片的数量；

**动态设置**

**mapping**

**merge**

ES 中 `shard` 是一个 `Lucene` 索引，`Lucene` 索引分割成 `segments`。
- `segment` 不可变；
- `segment` 周期性的合并来除去删除以及保持 `index` 大小；
- `ConcurrentMergeScheduler` 控制合并线程数。

**相似性**

**存储**

根据系统选择最佳的存储。

**translog**

**index 排序**

```shell
curl -X PUT "localhost:9200/my-index-000001?pretty" -H 'Content-Type: application/json' -d'
{
  "settings": {
    "index": {
      "sort.field": [ "username", "date" ], 
      "sort.order": [ "asc", "desc" ]       
    }
  },
  "mappings": {
    "properties": {
      "username": {
        "type": "keyword",
        "doc_values": true
      },
      "date": {
        "type": "date"
      }
    }
  }
}
'
```

- 先按照 `username` **升序**，然后按照 `date` **降序**。
- 可以使连接更有效。

## Mapping

**创建索引附带 mapping**

```shell
curl -X PUT "localhost:9200/my-index-000001?pretty" -H 'Content-Type: application/json' -d'
{
  "mappings": {
    "properties": {
      "age":    { "type": "integer" },  
      "email":  { "type": "keyword"  }, 
      "name":   { "type": "text"  }     
    }
  }
}
'
```

**查看 mapping**

```shell
curl -X GET "localhost:9200/my-index-000001/_mapping?pretty"
```

**查看字段的 mapping**

```shell
GET /my-index-000001/_mapping/field/employee-id
```

### 字段类型

**Array**

没有专用的数据类型。都是 `Lucence` 的成果。
- Lucene tokenizes the text into individual terms;
- 每个 `term` 分别加入到 `indverted index` 中。