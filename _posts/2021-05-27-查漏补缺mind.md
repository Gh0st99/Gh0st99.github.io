---
layout: post
title:  "查漏补缺思维导图"
date:   2021-05-27 13:20:06 +0800
categories: 面试
---


# 查漏补缺

## Java
![java]({{ site.url }}/assets/imgs/resume/java.svg)

---

## JVM

![jvm]({{ site.url }}/assets/imgs/resume/jvm.svg)


---

## MySQL


![mysql]({{ site.url }}/assets/imgs/resume/mysql.svg)


![explain]({{ site.url }}/assets/imgs/resume/explain.svg)

![extra]({{ site.url }}/assets/imgs/resume/extra.svg)

---

## Redis

![redis]({{ site.url }}/assets/imgs/resume/redis.svg)

---
## ES

![es]({{ site.url }}/assets/imgs/resume/es.svg)

---
## 分布式

![distributed]({{ site.url }}/assets/imgs/resume/distributed.svg)

---
## Linux
![linux]({{ site.url }}/assets/imgs/resume/linux.svg)

---

## 网络
![network]({{ site.url }}/assets/imgs/resume/network.svg)

---

## Spring

![spring]({{ site.url }}/assets/imgs/resume/spring.svg)


---
---
### synchronized
#### 原理

`Synchronized` 的语义底层是通过一个 `monitor` 的对象来完成，其实 `wait/notify` 等方法也依赖于 `monitor` 对象，这就是为什么只有在同步的块或者方法中才能调用 `wait/notify` 等方法，否则会抛出 **java.lang.IllegalMonitorStateException** 的异常的原因。


![sync-markword]({{ site.url }}/assets/imgs/resume/sync-markword.png)

![sync-flow]({{ site.url }}/assets/imgs/resume/sync-flow.png)


- monitorenter & monitorexit
- ACC_SYNCHRONIZED 

### TCP 最多可建立多少个连接？
```
fs.file-max： 当前系统可打开的最大数量
fs.nr_open： 当前系统单个进程可打开的最大数量
nofile： 每个用户的进程可打开的最大数量
```

linux 下一切皆文件，包括 socket。所以每当进程打开一个 socket 时候，内核实际上都会创建包括 file 在内的几个内核对象。该进程如果打开了两个 socket，那么它的内核对象结构如下图。

![tcp-socket-file]({{ site.url }}/assets/imgs/resume/tcp-socket-file.jpg)

