---
layout: post
title:  "查漏补缺思维导图"
date:   2021-05-27 13:20:06 +0800
categories: 面试
---


# 查漏补缺

## Java
![java]({{ site.url }}/assets/imgs/resume/java.svg)

---

## JVM

![jvm]({{ site.url }}/assets/imgs/resume/jvm.svg)


---

## MySQL


![mysql]({{ site.url }}/assets/imgs/resume/mysql.svg)


![explain]({{ site.url }}/assets/imgs/resume/explain.svg)

![extra]({{ site.url }}/assets/imgs/resume/extra.svg)

---

## Redis

![redis]({{ site.url }}/assets/imgs/resume/redis.svg)

---
## ES

![es]({{ site.url }}/assets/imgs/resume/es.svg)

---
## 分布式

![distributed]({{ site.url }}/assets/imgs/resume/distributed.svg)

---
## Linux
![linux]({{ site.url }}/assets/imgs/resume/linux.svg)

---

## 网络
![network]({{ site.url }}/assets/imgs/resume/network.svg)

---

## Spring

![spring]({{ site.url }}/assets/imgs/resume/spring.svg)


---
---
### synchronized
#### 原理

`Synchronized` 的语义底层是通过一个 `monitor` 的对象来完成，其实 `wait/notify` 等方法也依赖于 `monitor` 对象，这就是为什么只有在同步的块或者方法中才能调用 `wait/notify` 等方法，否则会抛出 **java.lang.IllegalMonitorStateException** 的异常的原因。

- monitorenter & monitorexit
- ACC_SYNCHRONIZED 

![sync-markword]({{ site.url }}/assets/imgs/resume/sync-markword.png)

机制与 `AQS` 是很相似的，只不过 `AQS` 中是一个同步队列多个等待队列。

![sync-flow]({{ site.url }}/assets/imgs/resume/sync-flow.png)

##### 结构
```c++
ObjectMonitor() {
    _header       = NULL;
    _count        = 0;
    _waiters      = 0,       // 等待中的线程数
    _recursions   = 0;       // 线程重入次数
    _object       = NULL;    // 存储该 monitor 的对象
    _owner        = NULL;    // 指向拥有该 monitor 的线程
    _WaitSet      = NULL;    // 等待线程 双向循环链表_WaitSet 指向第一个节点
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;   // 多线程竞争锁时的单向链表
    FreeNext      = NULL ;
    _EntryList    = NULL ;   // _owner 从该双向循环链表中唤醒线程，
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
    _previous_owner_tid = 0; // 前一个拥有此监视器的线程 ID
  }
```
- `_owner`：初始时为 `NULL`。当有线程占有该 `monitor` 时 `owner` 标记为该线程的 `ID`。当线程释放 `monitor` 时 `owner` 恢复为 `NULL`。`owner` 是一个临界资源 `JVM` 是通过 `CAS` 操作来保证其线程安全的。
- `_cxq`：竞争队列所有请求锁的线程首先会被放在这个队列中（单向）。`_cxq` 是一个临界资源 `JVM` 通过 `CAS` 原子指令来修改 `_cxq` 队列。
    - 每当有新来的节点入队，它的 `next` 指针总是指向之前队列的头节点，而 `_cxq` 指针会指向该新入队的节点，所以是后来居上。
- `_EntryList`： `_cxq` 队列中**有资格成为候选资源的线程**会被移动到该队列中。
- `_WaitSet`: 等待队列因为调用 `wait` 方法而**被阻塞**的线程会被放在该队列中。

##### 竞争

- 通过 `CAS` 尝试把 `monitor` 的 `owner` 字段设置为当前线程。
- 如果设置之前的 `owner` **指向当前线程**，说明当前线程**再次进入** `monitor`，即重入锁执行 `recursions++` , 记录重入的次数。(**可重入性**)
- 如果当前线程是第一次进入该 `monitor`, 设置 `recursions` 为 1, `_owner` 为**当前线程**，该线程成功获得锁并返回。
- 如果获取锁失败，则**等待**锁的释放。

##### 等待

- 当前线程被封装成 `ObjectWaiter` 对象 `node`，状态设置成 `ObjectWaiter::TS_CXQ。
- `for` 循环通过 `CAS` 把 `node` 节点 push 到 `_cxq` 列表中，同一时刻可能有多个线程把自己的 `node` 节点 push 到 `_cxq` 列表中。
- `node` 节点 push 到 `_cxq` 列表之后，通过**自旋**尝试获取锁，如果还是**没有获取到锁**则通过 `park` 将当前线程**挂起等待被唤醒**。
- 当该线程**被唤醒**时会从挂起的点继续执行，通过 `ObjectMonitor::TryLock` **尝试获取锁**。

##### 释放

当某个持有锁的线程执行完同步代码块时，会**释放锁**并 `unpark` **后续线程**。

##### notify

`notify` 或者 `notifyAll` 方法可以**唤醒同一个锁监视器下调用 wait 挂起的线程**，将其放入 `_EntryList`。


---

### 线程池

#### 线程获取任务

`getTask()`

![threadpool-gettask]({{ site.url }}/assets/imgs/resume/threadpool-gettask.jpg)

走👈🏻的是不可回收的核心线程，走👉🏻的是限 keepalive 时间，非核心线程 + 可回收的核心线程。

如果返回的是 `null`，则将 `ctl` cas(-1)。

调用 `processWorkerExit` 清理线程。

获取任务不为 null，会上自己的一把锁执行任务。

#### 参数动态化

##### setCorePoolSize

![threadpool-setcoresize]({{ site.url }}/assets/imgs/resume/threadpool-setcoresize.jpg)

##### setKeepAliveTime

如果时间改小，则 `interruptIdleWorkers`。

```java
final ReentrantLock mainLock = this.mainLock;
mainLock.lock();
try {
    for (Worker w : workers) {
        Thread t = w.thread;
        // 尝试获得锁成功，则表明其空闲
        if (!t.isInterrupted() && w.tryLock()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            } finally {
                w.unlock();
            }
        }
        if (onlyOne)
            break;
    }
} finally {
    mainLock.unlock();
}
```

##### setMaximumPoolSize

`interruptIdleWorkers`。

#### 异常处理

##### submit

```java
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}

protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
    return new FutureTask<T>(callable);
}

// FutureTask::run
public void run() {
    // ...
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                // 生吞了异常
                setException(ex);
            }
            if (ran)
                set(result);
        }
    } finally {
        // ...
    }
}
// FutureTask::setException
protected void setException(Throwable t) {
    if (STATE.compareAndSet(this, NEW, COMPLETING)) {
        // 将异常设置为结果
        outcome = t;
        STATE.setRelease(this, EXCEPTIONAL); // final state
        finishCompletion();
    }
}

private V report(int s) throws ExecutionException {
    Object x = outcome;
    if (s == NORMAL)
        return (V)x;
    if (s >= CANCELLED)
        throw new CancellationException();
    // 抛出异常
    throw new ExecutionException((Throwable)x);
}

public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s <= COMPLETING)
        s = awaitDone(false, 0L);
    // 获得结果
    return report(s);
}
```

只有在 `get()` 时抛出异常。


##### execute

任务都是由 `Worker` 执行。

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
    public void run() {
        runWorker(this);
    }

    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    try {
                        task.run();
                        afterExecute(task, null);
                    } catch (Throwable ex) {
                        // 遇到异常，抛出异常
                        afterExecute(task, ex);
                        throw ex;
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
}
```
---

### Redis Cluster

- `6379` 服务客户端；
- `16379` cluster bus，节点间通信的二进制通道；
  - 故障检测
  - 配置更新
  - 故障转移授权

不使用一致性 hash，使用 `hash slot`。有 `16384 slot`，`CRC16(key) mod 16384` 来分配。e.g.

- Node A contains hash slots from 0 to 5500.
- Node B contains hash slots from 5501 to 11000.
- Node C contains hash slots from 11001 to 16383.

增删节点：
- 假如要 + D，就把 A，B，C 中的一些 `hash slot`
- 假如要 - A，就把 A 中的 `hash slot` 移动啊B，C 中

**hash tag**

`this{foo}` 和 `another{foo}` 在一个 `hash slot` 中，可以在一条命令中执行多键操作。

**master slave**

`A` & `B` & `C` 每个增加一个 `slave` 节点。

`B` GG 后， `B1` 被选举新的 `master`。

**一致性保证**

特定情况下，可能回丢失系统向客户端确认的写入。

原因是使用异步复制：
- 客户端写入 master B;
- master B 回复 OK;
- master B 传播写到 B1, B2, B3。

丢失数据可能：
1. 假如，master B 回复后， gg 了，还没来得及传播，B1 当选，就丢失了写数据。

> 如同其他数据库，每 s 同步到硬盘一样。可强制同步复制、写(**WAIT**)，但是回降低性能。即使同步写也不能保证强一致性。

2.  网络分区，B 和 客户端 Z1 与其他分区了。Z1 能写入 B。如果分区持续足够久时间让 B1 在分区的多数侧提升为 master，则 Z1 同时发送给 B 的写入将丢失。

> **node timeout**: Z1 能够发送到 B 的写入量有一个 max window：如果分区的多数侧已经有足够的时间来选举一个 slave作为 master，那么少数侧的每个主节点都将停止接受写入


#### 容错性

##### 心跳和 gossip 消息

heartbeat:
- ping
- pong
- 两个都包含重要的配置信息

gossip 消息：
- 

---

### TCP 最多可建立多少个连接？
```
fs.file-max： 当前系统可打开的最大数量
fs.nr_open： 当前系统单个进程可打开的最大数量
nofile： 每个用户的进程可打开的最大数量
```

linux 下一切皆文件，包括 socket。所以每当进程打开一个 socket 时候，内核实际上都会创建包括 file 在内的几个内核对象。该进程如果打开了两个 socket，那么它的内核对象结构如下图。

![tcp-socket-file]({{ site.url }}/assets/imgs/resume/tcp-socket-file.jpg)

