---
layout: post
title:  "查漏补缺"
date:   2021-05-27 13:20:06 +0800
categories: 面试
---


# 查漏补缺

## Java
```plantuml
@startmindmap
* Java

** 并发 & 同步

*** synchronized
****_ 原理，可重入性，可见性
****_ 锁升级

*** volatile
****_ 可见性
****_ 内存屏障

*** 锁
****_ 乐观
****_ 悲观
****_ CAS
**** 死锁
*****_ 产生条件
*****_ 排查
**** reentrantlock
*****_ 实现原理，加锁和释放锁的一个过程
*****_ aqs
*****_ 公平和非公平
*****_ 可重入
*****_ 可中断

*** 并发工具类
**** concurrenthashmap
*****_ 怎么保证线程安全的
*****_ 为什么用synchronized
*****_ 分段锁有什么问题
*****_ hash算法做了哪些优化
**** threadlocal
*****_ 什么场景下使用的
*****_ 原理
*****_ hash冲突怎么办
*****_ 扩容实现
*****_ 内存泄漏产生原因，怎么解决


** 集合

*** hashmap
****_ 原理, put & get
****_ 8转红黑树?
****_ 什么时候扩容? 0.75？
****_ 扩容步骤，为什么分高低位
****_ 头插法有什么问题，为什么线程不安全 

*** arraylist
****_ 数组加transient
****_ 扩容原理


** 动态代理
***_ spring aop的理解，解决什么问题,实现原理
***_ jdk动态代理,cglib区别，优缺点

@endmindmap
```

## JVM

```plantuml
@startmindmap
* JVM

** 参数

** 类加载器
*** 分类
****_ Bootstrap ClassLoader
****_  Extension ClassLoader
****_ Application Classloader
****_ 自定义加载器
*** 双亲委派
****_ 机制
****_ 三次破坏

** GC
*** CMS
*** G1
***_ gc roots有哪些
***_ 什么情况下会发生full gc

** OOM
***_ 排查
***_ 产生原因
@endmindmap
```

## MySQL


![one-to-many-json-tree]({{ site.url }}/assets/imgs/resume/mysql.svg)
```plantuml
@startmindmap MySQL 脑图
<style>
boxless {
FontColor darkgreen
}
</style>

* MySQL

** Log [[https://zhuanlan.zhihu.com/p/58011817 MySQL日志分类及简介]]
***_ 错误日志
***_ 查询日志
***_ 慢查询日志 *
***_ 事务日志(Redo log) *
***_ 二进制日志
***_ 中继日志

** InnoDB
*** 结构 [[https://zhuanlan.zhihu.com/p/235458760 深入剖析InnoDB]]
****_ 缓冲池（Buffer Pool）*
****_ 写缓冲区(Change Buffer) *
****_ 日志缓冲区（log Buffer）*
****_ 自适应 Hash 索引
****_ Double Write Buffer

** ACID
*** Atomicity 中止（abort）
****_ 能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力
****_ 事物

*** Consistency 不变量（invariants）
****_ doublewrite buffer

*** Isolation
****_ 锁
**** 事物隔离级别
*****_ 读已提交（Read Committed）

*** Durability
****_ doublewrite buffer
****_ 运维

** 隔离级别
** MVCC
** 幻读

left side

** 锁
***_ Shared and Exclusive Locks
***_ Intention Locks
***_ Record Locks
***_ Gap Locks *
***_ Next-Key Locks *
***_ Insert Intention Locks
***_ AUTO-INC Locks

** explain
***_ id
*** select_type
****_ **SIMPLE**: 无 union 或 子查询
****_ **PRIMARY**: 最外
****_ **SUBQUERY**: 子查询中第一个 SELECT
****_ **DERIVED**
****_ **MATERIALIZED**

*** type
*** Extra
***_ possible_keys
***_ key 
***_ key_len: 使用的 key 的长度
***_ rows
***_ filterd
***_ extra


** 索引
*** 种类
****_ 聚簇索引
****_ 二级索引
****_ 覆盖索引
***_ 自动生成的主键有什么问题

@endmindmap
```

```plantuml
@startmindmap explain type 脑图
* explain type
**_ **system**: 表只有一行
**_ **const**: 最多一行匹配；主键或者唯一键
**_: 
**eq_ref**:  对于前面的
表中各种组合，此表只取出一行
;
**_:
**ref**: 对于前面的表的各种组合，
此表匹配的索引值
;

**_ **ref_or_null**: 像 ref 但再搜索 NULL 值

**_: 
**index_merge**: key 中反映的是索引
使用的 key 的列表。
一张表的多个 range 扫描合并成一个
合并可能是交集、并集、差集
;
left
**_ **unique_subquery**: in 中的 eq_ref
**_:
**index_subquery**: 类似 unique_subquery
但不是在 unique 索引上
;
**_ **range**: 指定区间中的行被拉取
**_: 
**index**: 连接类型同 all,只是索引树被扫描
覆盖索引满足查询的数据，Extra:  Using index，比 all 快，索引数据小
按照索引顺序进行全表查询，Extra 中没有
;
**_ **ALL**: 对先前表中的每个行组合进行全表扫描。非常不好，加索引
@endmindmap
```



```plantuml
@startmindmap explain extra 脑图
* explain extra
**_ **backward index scan**: 使用 descending index(降序索引)
**_ **Distinct**: 找到第一个符合的行后就不再找
**_: 
**FirstMatch(tbl_name)** 半连接找到第一个
半连接是一个子查询，它主要用于去重。只返回存在内表中的外表的记录，
EXSIT和IN语句组成的布尔表达式
;
**_:
**Using filesort** MySQL 必须执行额外的检查以找出如何按排序顺序检索行
找不到合适的索引来 order by。读表行来排序，如果临时结果集太大使用临时硬盘空间。
;
**_ **Using index**: 使用覆盖索引，不回表。也可以 type: index & key: primary
**_: 
**Using index condition**: 索引条件下推，减少读全表行的可能性。
没有 ICP: base table 遍历 index 来找行，交给 存储引擎，其在 WHERE。
有 ICP: where 中部分列能通过 index 满足，存储引擎
;
**_:
**Using temporary**: 需要创建临时表保留结果
一般是 group by 和 order by 不同的字段
;
**_:
**Using where** 限制了哪些行匹配到下张表或者传给客户端。
如果 join type: [all | index], 而没有此项，就全表了，有问题。
;
@endmindmap
```
## Redis

```plantuml
@startmindmap
* Redis
** 数据结构
*** Hash
****_ rehash
****_ 负载因子
*** Sorted Set
****_ skiplist
*** String
****_ SDS vs. C


** 集群
*** cluster
****_ 16384 slot?
****_ 原理

*** sentinel
****_ 选举过程
****_ 脑裂
****_ raft?

** 可用性
***_ 与数据库一致性
***_ 缓存雪崩
***_ 缓存击穿 单热点 key 失效，
***_ 缓存穿透，猛攻 key 不存在，布隆过滤器

** 分布式锁
***_ 实现方法
***_ 过期时间的制定
***_ 续锁
***_ RedLock

** 线程模型
***_ epoll
***_ 单线程的优缺点
***_ 什么情况下会出现阻塞，怎么解决
@endmindmap
```

## 分布式

```plantuml
@startmindmap
* 原理
** 一致性hash原理
***_ 解决的问题
***_ 数据倾斜
***_ 2^32 ?

** CAP

** BASE

** 幂等
@endmindmap
```