---
layout: post
title:  "深入理解 JVM 虚拟机"
date:   2020-04-11 16:16:27 +0800
categories: Java
---

# 深入理接 Java 虚拟机

## Java 内存区域 & 内存溢出异常

### 运行时数据区域

#### 程序计数器

1. 较小的内存空间；
2. 当前线程执行的字节码的行号指示器；
3. 字节码解释器通过修改这个的值获取下一条执行的字节码指令；
4. 每个线程一个独立的。

#### Java 虚拟机栈

1. 线程私有；
2. 每个方法执行，`VM Stack` 就会创建一个**栈帧**(`Stack Frame`)；
    - 局部变量表：相当于 `C++` 中的栈。下面数据以 `slot` 的形式存放。**所需的内存空间再编译期确定完成**。
        - 基本数据类型
        - 对象引用
        - returnAddress
    - 操作数栈
    - 动态连接
    - 方法出口

#### 本地方法栈

#### Java 堆

**几乎所有**的对象实例以及数组都在堆上分配。

`Java 堆`中分出多个线程私有的**分配缓冲区**(`Thread Local Allocation Buffer, TLAB`)提升对象分配的效率，更好的回收内存，更快的分配内存。

#### 方法区

存储被虚拟机加载的：
- 类型信息
- 常量
- 静态变量
- JIT 编译后的代码缓存

是堆的一个逻辑部分。**永久代**实现方法区，能像管理 `Java 堆` 一样管理方法区。现在是在本地内存中实现的**元空间**。

内存回收：
- 常量池的回收
- 类型的卸载

#### 运行时常量池

**是方法区的一部分**。存放 **编译期生成的字面量** 和 **符号引用** 以及 **翻译过来的直接引用**。可以在运行期间放入。

#### 直接内存

`NIO` 中 `DirectByteBuffer`。

### 对象的创建

当遇到 `new` 时。

- 检查指令的参数是否在常量池中定位到一个**类的符号引用**；
- 检查**符号引用**是否被加载，解析，初始化。如果没有，则进行前面操作；
- 为新生对象分配内存：
    - 方法：
        - 指针碰撞：**规整**内存。一侧放分配的，另一侧空的。
        - 空闲列表：**不规整**内存。
        > **规整**由是否带有 `Compact` 功能来决定。
    - 分配时保证线程安全：
        - 同步：`CAS`
        - 每个线程在 `Java 堆` 中先分配一小块内存，**TLAB**，需要分配内存现在 `TLAB` 中分配。当 `TLAB` **用完了才会分配新的缓存区时同步锁定**。
- 新分配的内存初始化 `0`；
- 对象必要的设置**对象头中相关信息**；
- 调用**构造函数** `<init>()`

### 对象内存布局

- 对象头：`Mark Word`
    - 对象自身运行时的数据
        - HashCode
        - GC 年龄分代
        - 锁状态
        - 线程持有的锁
        - 偏向线程 `ID`
        - 偏向时间戳
    - 类型指针：确定这个对象时哪个类型的实例
- 实例数据：**相同宽度**的字段总是被**分配到一起**存放，父类分配在子类之前(`+XX:FieldsAllocationStyle`)。子类较窄的允许插入到父类间隙中(`+XX:CompactFields`)。
- 对齐填充：8字节整数倍。

### 对象的访问定位

- 句柄：开出一块内存：句柄池，句柄包括：到对象**实例数据**的指针，到对象**类型数据**的指针。`reference` 存放的时对象的句柄地址。
- 直接指针：`reference`存放的时对象的直接地址。需要考**虑如何放置访问类型数据的相关信息**。

## 垃圾收集器 & 内存回收策略

### 可达性分析

`GC Roots` 作为起始节点集，根据引用关系向下搜索。

- **虚拟机栈**中引用的对象；
- **方法区中静态属性**引用的对象；
- **方法区中常量**引用的对象；
- **本地方法栈中 JNI**引用的对象；
- **虚拟机内部的引用**:
    - `Class 对象`
    - 常驻的异常对象
    - 系统类加载器
- **被同步锁持有**的对象；
- 反映虚拟机内部情况的 `JMXBean`、`本地代码缓存`、`JVMTI中注册的回调`。

### 引用类型

- 强：引用复制 `xxx = new XXX()`
- 软：**还有用，但非必须**。系统**将要发生内存溢出异常前**，**列进回收范围**之中进行**第二次回收**。
- 弱：**非必须对象**。只能生产难道下一次垃圾收集发生为止。无论内存是否够用。
- 虚：不会对其生存时间构成影响，也无法通过其来获取对象的实例。目的：在对象被回收前收到一个系统通知。

### finalize() 自救

`finalize` 将要被弃用，不写了。

### 回收方法区

收集：
- 废弃的常量；
- 不再使用的类型。

满足条件：
- 所有实例都已经被回收；
- 加载该类的类加载器已经被回收；
- 对应的 `Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾回收算法

#### 分代回收

基于：
- 弱分代假说：绝大多数对象朝生夕灭；
- 强分代假说：熬过越多次越难以消亡。
> **新生代**、**老年代**。
- 跨代引用假说：跨代引用占极少数
> 对象不是孤立的，可能存在跨代引用，新生代的对象被老年代引用，进而进行 `Minor GC` 新生代回收时需要遍历老年代。

> 只需在新生代上建立一个全局的数据结构（**记忆集**），这个结构把老年代分成了若干块，**标记出老年代的哪一块内存会存在跨代引用**。

GC 种类：

- Minor GC：只收集**新生代**；
- Major GC：只收集**老年代**（`CMS` 独有）；
- Mixed GC：**整个新生代**以及**部分老年代**（`G1` 独有）；
- Full GC：整个 `Java 堆` 和 `方法区`。

GC 算法：

- Mark-Sweep：
    - 1. 标记所有需要回收的对象；
    - 2. 同一对标记的进行回收。
    > 执行效率不稳定，大量对象慢；产生空间碎片会引起下一次垃圾回收。
- Mark-Copy：为了解决上面大量对象效率低：
    - 半区复制：将内存划分为两个大小相同的块。每次只是用其中一块。将存活对象复制到另一块，清除原来的那块。
    - Appel 式回收：**新生代**划分为一个较大的 `Eden` 和两个较小的 `Survivor`。
        - `Eden`、一个`Survivor` 一次性复制到另一个 `Survivor`。清理原来的两个区。 `Eden` : 一个 `Survivor` 为 8 : 1。
        - 当 `Survivor` 不足以容纳一次 `Minor GC`时，有一个**逃生门**设计，即**另一个内存区域**（老年代）进行**分配担保**。即无法容纳的对象直接进入老年代了。
- Mark-Compact：当存活率较高时，上面的算法就会进行较多的复制，效率会降低。如果不想浪费 50% 的空间，就需要额外的空间进行担保，`Mark-Copy` **不适合老年代**。
    - 类似于 `Mark-Sweep`，但是**不是清除**而是**向空间的另一端移动**，然后直接清理掉边界以外的内存。
    - `M-Compact` vs. `M-Sweep`：
        - 移动需要更新这些对象的引用，**负担大**；必须要 `Stop The World`。
        > 回收时复杂
        - 不移动，需要考虑空间碎片，要解决只能**依赖更复杂的内存分配器和访问器**：如`分区空闲分配链表`。
        > 分配时复杂

        > 但是整个吞吐量（`GC` 的用户程序）来说，**移动更划算**。
    > 或者多数时间使用 `M-Sweep`，容忍内存碎片。受不了了来一下 `M-Compact`。

### HotSpot 算法细节

#### 根节点枚举

根节点枚举期间**必须 STW**。

使用 `OopMap`:类加载动作完成，会把对象内类型的偏移量计算出来。来获取哪些地方存放对象引用的。

#### 安全点


可能导致引用变化的指令太多，不能为所有指令生成 `OopMap`。只是在 **安全点** 生成了 `OopMap`。

> 强制要求必须执行到安全点后才能暂停。


**安全点位置的选取**：**是否有让程序长时间执行的特征**（明显特征**指令序列的复用**）来选定。
- 方法调用
- 循环跳转
- 异常跳转

**安全点如何停止线程**：垃圾回收时让所有线程跑到最近的安全点，然后停顿。
- **抢先式**：所有线程先中断，没有在安全点的回复这些线程，再跑一会儿中断。
- **主动式**：设置一个标志位，各个线程不停地主动轮询这个标志，一旦发现这个为真，就再最近的安全点上主动中断挂起。
    - 轮询标志地方：
        - 与安全点重合；
        - 所有创建对象和其他需要在 `Java 堆` 上分配内存的地方（检查是否即将要发生垃圾收集，避免没有足够内存）。
    - 轮询操作使用：内存保护陷阱的方式。eg. `test %eax, 0x160100`。把内存页 `0x160100` 设置为不可读，执行上面指令时会产生一个**自陷异常信号**，在**预先注册的异常信号处理器**中**挂起线程**实现等待。

#### 安全区域

因为存在程序“不执行”的情况（`sleep`, `Blocked`）。线程**无法响应中断请求**也就不能走到安全的地方挂起自己。而不能等待器获得时间片。

安全区域：保证某一段代码片段中，**引用关系不发生变化**。在这个区域中任意地方开售垃圾收集都是安全的。安全点的拉长。

- 在**执行安全区域内的代码**时，首先**标识进入了安全区域**。如果发生了垃圾收集就不必区关这些线程。
- 线程离开**安全区域**需要**检查是否将已经完成了根节点枚举**，如果**没完成就必须一直等待**，直到收到可以离开安全区域的信号为止。

#### 记忆集与卡表

为了**避免整个老年代**加进 `GC Roots` 的扫描范围（跨代引用）。

用于记录 **非收集区域** -> **收集区域** 的指针集合的 `ADT`。
- 最简单的：**非收集区域**中**所有含跨代引用**的**对象数组**。
> 但是 `垃圾收集` 并不需要这些细节。**只需**要通过记忆集**判断某一块非收集区域是否存在有指向手机区域的指针就行**。

记录精度：
- 字长精度：一个 `Word` 是否包含？
- 对象精度：一个对象里有字段包含？
- 卡精度（卡表，是上面 `ADT` 的实现）：精确到一个内存区域，该区域是否包含？
    - 以字节数组的形式。数组中每个元素对应标识的内存区域中一块**特定大小的内存块**（卡页：2^N）。

#### 写屏障

**如何维护卡表**元素。when，who 让它变脏。

- when: 其他分代区域中的对象引用了本区域的对象；
- how：每一个赋值操作中。**写屏障**，类似于**引用字段类型赋值**的 `AOP`。在这个 `AOP` 中进行维护。
    - 赋值前：大多数
    - 赋值后：`G1` 以后

写屏障缺点：
- 开销：每次对引用更行都会有开销；
- 伪共享：都是以缓存行的方式。多线程修改相互独立变量但是这些变量在一个缓存行中产生。解决：**只有检查没有被标记过时才将其标记变脏**。