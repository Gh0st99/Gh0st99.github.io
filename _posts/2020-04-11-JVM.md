---
layout: post
title:  "深入理解 JVM 虚拟机"
date:   2020-04-11 16:16:27 +0800
categories: Java
---

# 深入理接 Java 虚拟机

## Java 内存区域 & 内存溢出异常

### 运行时数据区域

#### 程序计数器

1. 较小的内存空间；
2. 当前线程执行的字节码的行号指示器；
3. 字节码解释器通过修改这个的值获取下一条执行的字节码指令；
4. 每个线程一个独立的。

#### Java 虚拟机栈

1. 线程私有；
2. 每个方法执行，`VM Stack` 就会创建一个**栈帧**(`Stack Frame`)；
    - 局部变量表：相当于 `C++` 中的栈。下面数据以 `slot` 的形式存放。**所需的内存空间再编译期确定完成**。
        - 基本数据类型
        - 对象引用
        - returnAddress
    - 操作数栈
    - 动态连接
    - 方法出口

#### 本地方法栈

#### Java 堆

**几乎所有**的对象实例以及数组都在堆上分配。

`Java 堆`中分出多个线程私有的**分配缓冲区**(`Thread Local Allocation Buffer, TLAB`)提升对象分配的效率，更好的回收内存，更快的分配内存。

#### 方法区

存储被虚拟机加载的：
- 类型信息
- 常量
- 静态变量
- JIT 编译后的代码缓存

是堆的一个逻辑部分。**永久代**实现方法区，能像管理 `Java 堆` 一样管理方法区。现在是在本地内存中实现的**元空间**。

内存回收：
- 常量池的回收
- 类型的卸载

#### 运行时常量池

**是方法区的一部分**。存放 **编译期生成的字面量** 和 **符号引用** 以及 **翻译过来的直接引用**。可以在运行期间放入。

#### 直接内存

`NIO` 中 `DirectByteBuffer`。

### 对象的创建

当遇到 `new` 时。

- 检查指令的参数是否在常量池中定位到一个**类的符号引用**；
- 检查**符号引用**是否被加载，解析，初始化。如果没有，则进行前面操作；
- 为新生对象分配内存：
    - 方法：
        - 指针碰撞：**规整**内存。一侧放分配的，另一侧空的。
        - 空闲列表：**不规整**内存。
        > **规整**由是否带有 `Compact` 功能来决定。
    - 分配时保证线程安全：
        - 同步：`CAS`
        - 每个线程在 `Java 堆` 中先分配一小块内存，**TLAB**，需要分配内存现在 `TLAB` 中分配。当 `TLAB` **用完了才会分配新的缓存区时同步锁定**。
- 新分配的内存初始化 `0`；
- 对象必要的设置**对象头中相关信息**；
- 调用**构造函数** `<init>()`

### 对象内存布局

- 对象头：`Mark Word`
    - 对象自身运行时的数据
        - HashCode
        - GC 年龄分代
        - 锁状态
        - 线程持有的锁
        - 偏向线程 `ID`
        - 偏向时间戳
    - 类型指针：确定这个对象时哪个类型的实例
- 实例数据：**相同宽度**的字段总是被**分配到一起**存放，父类分配在子类之前(`+XX:FieldsAllocationStyle`)。子类较窄的允许插入到父类间隙中(`+XX:CompactFields`)。
- 对齐填充：8字节整数倍。

### 对象的访问定位

- 句柄：开出一块内存：句柄池，句柄包括：到对象**实例数据**的指针，到对象**类型数据**的指针。`reference` 存放的时对象的句柄地址。
- 直接指针：`reference`存放的时对象的直接地址。需要考**虑如何放置访问类型数据的相关信息**。

---

## 垃圾收集器 & 内存回收策略

### 可达性分析

`GC Roots` 作为起始节点集，根据引用关系向下搜索。

- **虚拟机栈**中引用的对象；
- **方法区中静态属性**引用的对象；
- **方法区中常量**引用的对象；
- **本地方法栈中 JNI**引用的对象；
- **虚拟机内部的引用**:
    - `Class 对象`
    - 常驻的异常对象
    - 系统类加载器
- **被同步锁持有**的对象；
- 反映虚拟机内部情况的 `JMXBean`、`本地代码缓存`、`JVMTI中注册的回调`。

### 引用类型

- 强：引用复制 `xxx = new XXX()`
- 软(SoftReference)：**还有用，但非必须**。系统**将要发生内存溢出异常前**，**列进回收范围**之中进行**第二次回收**。
- 弱(WeakReference)：**非必须对象**。只能生存到下一次垃圾收集发生为止。无论内存是否够用。
- 虚(PhantomReference)：不会对其生存时间构成影响，也无法通过其来获取对象的实例。目的：在对象被回收前收到一个系统通知。

### finalize() 自救

`finalize` 将要被弃用，不写了。

### 回收方法区

收集：
- 废弃的常量；
- 不再使用的类型。

满足条件：
- 所有实例都已经被回收；
- 加载该类的类加载器已经被回收；
- 对应的 `Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾回收算法

#### 分代回收

基于：
- 弱分代假说：绝大多数对象朝生夕灭；
- 强分代假说：熬过越多次越难以消亡。
> **新生代**、**老年代**。
- 跨代引用假说：跨代引用占极少数
> 对象不是孤立的，可能存在跨代引用，新生代的对象被老年代引用，进而进行 `Minor GC` 新生代回收时需要遍历老年代。

> 只需在新生代上建立一个全局的数据结构（**记忆集**），这个结构把老年代分成了若干块，**标记出老年代的哪一块内存会存在跨代引用**。

GC 种类：

- Minor GC：只收集**新生代**；
- Major GC：只收集**老年代**（`CMS` 独有）；
- Mixed GC：**整个新生代**以及**部分老年代**（`G1` 独有）；
- Full GC：整个 `Java 堆` 和 `方法区`。

GC 算法：

- Mark-Sweep：
    - 1. 标记所有需要回收的对象；
    - 2. 同一对标记的进行回收。
    > 执行效率不稳定，大量对象慢；产生空间碎片会引起下一次垃圾回收。
- Mark-Copy：为了解决上面大量对象效率低：
    - 半区复制：将内存划分为两个大小相同的块。每次只是用其中一块。将存活对象复制到另一块，清除原来的那块。
    - Appel 式回收：**新生代**划分为一个较大的 `Eden` 和两个较小的 `Survivor`。
        - `Eden`、一个`Survivor` 一次性复制到另一个 `Survivor`。清理原来的两个区。 `Eden` : 一个 `Survivor` 为 8 : 1。
        - 当 `Survivor` 不足以容纳一次 `Minor GC`时，有一个**逃生门**设计，即**另一个内存区域**（老年代）进行**分配担保**。即无法容纳的对象直接进入老年代了。
- Mark-Compact：当存活率较高时，上面的算法就会进行较多的复制，效率会降低。如果不想浪费 50% 的空间，就需要额外的空间进行担保，`Mark-Copy` **不适合老年代**。
    - 类似于 `Mark-Sweep`，但是**不是清除**而是**向空间的另一端移动**，然后直接清理掉边界以外的内存。
    - `M-Compact` vs. `M-Sweep`：
        - 移动需要更新这些对象的引用，**负担大**；必须要 `Stop The World`。
        > 回收时复杂
        - 不移动，需要考虑空间碎片，要解决只能**依赖更复杂的内存分配器和访问器**：如`分区空闲分配链表`。
        > 分配时复杂

        > 但是整个吞吐量（`GC` 的用户程序）来说，**移动更划算**。
    > 或者多数时间使用 `M-Sweep`，容忍内存碎片。受不了了来一下 `M-Compact`。

### HotSpot 算法细节

#### 根节点枚举

根节点枚举期间**必须 STW**。

使用 `OopMap`:类加载动作完成，会把对象内类型的偏移量计算出来。来获取哪些地方存放对象引用的。

#### 安全点


可能导致引用变化的指令太多，不能为所有指令生成 `OopMap`。只是在 **安全点** 生成了 `OopMap`。

> 强制要求必须执行到安全点后才能暂停。


**安全点位置的选取**：**是否有让程序长时间执行的特征**（明显特征**指令序列的复用**）来选定。
- 方法调用
- 循环跳转
- 异常跳转

**安全点如何停止线程**：垃圾回收时让所有线程跑到最近的安全点，然后停顿。
- **抢先式**：所有线程先中断，没有在安全点的回复这些线程，再跑一会儿中断。
- **主动式**：设置一个标志位，各个线程不停地主动轮询这个标志，一旦发现这个为真，就再最近的安全点上主动中断挂起。
    - 轮询标志地方：
        - 与安全点重合；
        - 所有创建对象和其他需要在 `Java 堆` 上分配内存的地方（检查是否即将要发生垃圾收集，避免没有足够内存）。
    - 轮询操作使用：内存保护陷阱的方式。eg. `test %eax, 0x160100`。把内存页 `0x160100` 设置为不可读，执行上面指令时会产生一个**自陷异常信号**，在**预先注册的异常信号处理器**中**挂起线程**实现等待。

#### 安全区域

因为存在程序“不执行”的情况（`sleep`, `Blocked`）。线程**无法响应中断请求**也就不能走到安全的地方挂起自己。而不能等待器获得时间片。

安全区域：保证某一段代码片段中，**引用关系不发生变化**。在这个区域中任意地方开售垃圾收集都是安全的。安全点的拉长。

- 在**执行安全区域内的代码**时，首先**标识进入了安全区域**。如果发生了垃圾收集就不必区关这些线程。
- 线程离开**安全区域**需要**检查是否将已经完成了根节点枚举**，如果**没完成就必须一直等待**，直到收到可以离开安全区域的信号为止。

#### 记忆集与卡表

为了**避免整个老年代**加进 `GC Roots` 的扫描范围（跨代引用）。

用于记录 **非收集区域** -> **收集区域** 的指针集合的 `ADT`。
- 最简单的：**非收集区域**中**所有含跨代引用**的**对象数组**。
> 但是 `垃圾收集` 并不需要这些细节。**只需**要通过记忆集**判断某一块非收集区域是否存在有指向手机区域的指针就行**。

记录精度：
- 字长精度：一个 `Word` 是否包含？
- 对象精度：一个对象里有字段包含？
- 卡精度（**卡表**，是上面 `ADT` 的实现）：精确到一个内存区域，该区域是否包含？
    - 以字节数组的形式。数组中每个元素对应标识的内存区域中一块**特定大小的内存块**（卡页：2^N）。

#### 写屏障

**如何维护卡表**元素。when，who 让它变脏。

- when: 其他分代区域中的对象引用了本区域的对象；
- how：每一个赋值操作中。**写屏障**，类似于**引用字段类型赋值**的 `AOP`。在这个 `AOP` 中进行维护。
    - 赋值前：大多数
    - 赋值后：`G1` 以后

写屏障缺点：
- 开销：每次对引用更行都会有开销；
- 伪共享：都是以缓存行的方式。多线程修改相互独立变量但是这些变量在一个缓存行中产生。解决：**只有检查没有被标记过时才将其标记变脏**。

#### 并发的可达行分析

`GC Roots` 再继续往下遍历对象图，这一段时间与堆容量正比。

三色标记法：

- 白色：尚未被垃圾回收器访问过；
- 黑色：已经被访问，且这个对象所有引用被扫描过；
    - 黑色不可直接指向白色；
- 灰色：已经被访问，但对象上至少存在一个引用还没被扫描过。

**对象消失**：在标记时并发修改了引用关系。

产生的原因（两个条件同时满足）：

- 赋值器**插入**一条或多条从**黑色 -> 白色**的**新引用**；
- 赋值器**删除**  **全部灰色 -> 白色** 的**直接引用或间接引用**。

只需破坏一个即可，方法如下：

- 增量更新：破坏第一个条件。（`CMS`）
    - 当**黑色对象插入新的指向白色对象的引用关系**时，将**新插入的引用记录**；
    - **并发扫描结束**，将**记录的黑色对象为跟，再扫描一次**；
    - **相当于黑色对象插入了指向白色对象之后 -> 灰色对象**。
- 原始快照：破坏第二个条件。（`G1`, `Shenandoah`）
    - 记录下删除的引用；
    - 并发结束之后，再将灰色为根，重新标记；
    - **无论引用关系是否删除，都会按照刚开始扫描那一刻的对象图进行搜索**。

> 都是通过**写屏障**实现。

### 经典垃圾回收器

**经典** 是与 `JDK 11` 发布的高性能低延迟分开。


![3-6]({{ site.url }}/assets/imgs/jvm/jvm-3-6.png)

上面连线表示可以搭配使用

#### Serial(Mark-Copy)

**单线程**工作的收集器。单线程是指在进行 `GC` 时，必须**暂停其他所有工作的线程**（`Stop The World`），直到收集结束。

![3-7]({{ site.url }}/assets/imgs/jvm/jvm-3-7.png)

- 缺点：
    - 慢
- 优点：
    - 额外内存消耗（`Memory Footprint`）最小；
    - 对于核心数少的环境，**没有线程交互的开销**，可以获得最高的单线程收集效率。

> 在**客户端**模式下不错。

#### ParNew(Mark-Copy)

上面的并行版本，除了同时使用多条线程 `GC`，没啥区别。

`JDK 7` 之前，**服务端**首选。

![3-8]({{ site.url }}/assets/imgs/jvm/jvm-3-8.png)

成功的原因是 `CMS` 收集老年代不能与 `Parallel Scavenge` 合作。它是唯一能与 `CMS` 配合工作的。随着 `CMS` 兴起而兴起。

默认开启的**收集线程数**与**处理核心数**相同。

**GC 中并发与并行的区别**：

> Parallel: **并行**是**多条垃圾收集器线程**之间的关系，**同一时间多条线程协同工作**，通常**默认用户线程处于等待**。

> Concurrent: **并发**是**垃圾回收器线程**与**用户线程**之间的关系，**同一时间垃圾回收器线程与用户线程都在运行**。

#### Parallel Scavenge(Mark-Copy)

同样是 `标记-复制` 算法。目标是**达到一个可控制的吞吐量**。 `CMS` **尽可能地缩短垃圾收集时用户线程停顿的时间**。

```
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间)
```

- -XX:MaxGCPauseMillis，最大停顿时间，设置越小，次数越多；
- -XX:GCTimeRatio，直接设置吞吐量大小，假设 `19`，则 `1/(1 + 19)`，垃圾回收时间占 `5%`。
- -XX:UseAdaptiveSizePolicy，不需要人工指定 `-Xmn`, `-XX:SurvivorRatio`, `-XX:PretenureSizeThreshold`

#### Serial Old(Mark-Compact)

![3-6]({{ site.url }}/assets/imgs/jvm/jvm-3-6.png)

- 客户端模式使用；
- `CMS` 失败后的后备方案。

#### Parallel Old(Mark-Compact)

`Parallel Scavenge` 老年代版本。

![3-10]({{ site.url }}/assets/imgs/jvm/jvm-3-10.png)

在注重吞吐量或资源稀缺时，优先考虑 `Parallel Scavenge` + `Parallel Old`。


#### CMS(Mark-Sweep)

- 初始标记(initial mark `STW`)
- 并发标记(concurrent mark)
- 重新标记(remark `STW`)
- 并发清除(concurrent sweep)

![3-11]({{ site.url }}/assets/imgs/jvm/jvm-3-11.png)

缺点：

- 处理器资源非常敏感；
    - 面向并发设计的都对其敏感；
    - 占用一部分线程，导致应用程序变慢；
- 无法处理“浮动垃圾”，可能出现 `Concurrent Mode Failure` 失败导致另一次完全 `STW` 的 `Full GC`；
    - 浮动垃圾：在并发标记、并发清除阶段产生的垃圾；
    - 由于有浮动垃圾，所以**不能等老年代几乎被填满再收集**，**必须留一部分空间**供并发收集时程序运行使用(会产生新的对象)；
    - 当预留的空间无法满足分配新对象的需要，就会**并发失败**（`Concurrent Mode Failure`）。冻结用户线程的执行，临时使用 `Serial Old` 重新进行老年代的垃圾收集；
    - `Mark-Compact` 回产生大量的空间碎片，提前触发 `Full GC`。
        - -XX:+UseCMSCompactAtFullCollection `Full GC` 开启碎片整合；
        - -XX:CMSFullGCsBeforeCompaction 在执行 `cms` 若干次不整理空间的 `Full GC` 进行 `Full GC`。

#### G1

**面向局部收集** + 基于 `Region` 的内存布局形式。

![3-13]({{ site.url }}/assets/imgs/jvm/jvm-3-13.jpg)


> 面向堆内存任何部分来组成**回收集**（`Collection Set`），衡量标准**不再是分代**，而是**哪块内存存放的垃圾数量最多，回收收益最大**。

> Mixed GC

- **仍遵从分代**收集；
- 把 `Java 堆` 划分为多个**大小相等的独立区域**（`Region`），每个区域根据需求，扮演 `Eden`、`Survivor` 或 `老年代`。能对扮演**不同角色的 `Region` 使用不同策略**；
- `Humoongous` 区域存放**大对象**： **> 0.5 Region 大小的对象**。**> 1 Region 大小的对象** 用多个连续 `Humoongous` 存放；
    - 大多数行为将 `Humoongous` 当作老年代看待。
- `-XX:G1HeapRegionSize` 设置 `Region` 大小， `1MB ~ 32MB`， `2^N`；
- 建立了**可预测的停顿时间模型**，是因为每次回收都是 `Region` 的整数倍；
    - 跟踪各个 `Region` 的**价值**：**回收获得的空间大小以及回收所需时间的经验值**；
    - 放在**优先队列**中；
    - `-XX:MaxGCPauseMillis` 设置的允许收集停顿时间来优先处理回收效益最大的 `Region`。

挑战：
- `Region` 中 `跨 Region` 引用对象怎么解决？
    - 使用**记忆集**，每个 `Region` 维护自己的**记忆集**
        - 记忆集**记录别的 Region 指向自己的指针**，并标记这些指针在哪些卡也的范围之内；
        - 本质上是 **哈希表**：`key` 别的 `Region` 的其实地址，`Value` 是一个集合，存卡表的索引号；
        - 双向索引，我 <-> 谁：`卡表`：我 -> 谁；
        - 占用额外的 `10 - 20` 内存。

- 并发标记阶段 `收集线程`、`用户线程` 互不干扰？
    - 原始快照（`STAB`）；
    - 每个 `Region` 设计两个 `TAMS` 指针，`Region` 中一部分空间划分出来用于**并发回收过程中的新对象回收**。**并发回收时新分配的对象地址必须在这两个指针位置上**，这个地址以上默认存活，不纳入回收范围；

- 如何建立可靠的停顿预测模型 `-XX:MaxGCPauseMillis`？
    - 衰减均值；
    - 记录每个 `Region` 回收耗时、`Region`记忆集里的脏卡数量等各个步骤的成本，得出平均值，标准偏差，置信度等；
    - 通过观察的值预测现在开始回收，哪些 `Region` 组成的**回收集**可以不超过期望的时间获得最高收益。

运作过程：

- 初始标记：
    - 标记 `GC Roots` 直接关联到的对象；
    - 修改 `TAMS` 指针的值，**下一阶段用户线程并发运行能正确地在可用的 `Region` 中分配新对象**；
    - STW，很短。`Minor GC` 时同步进行。
- 并发标记：
    - 对堆中对象进行可达性分析，递归扫描整个堆的对象图，找出要回收的对象；
    - 扫描完成后，还要重新处理 `STAB` 记录下的在**并发时有引用变动的对象**。
- 最终标记：
    - 并发阶段结束后，遗留下来的最后少量的 `STAB` 记录；
    - STW 很短。
- 筛选回收：
    - 更新 `Region` 的统计数据，排序价值，制定回收计划；
    - 把决定回收的那一部分 `Region` 的存活对象复制到空的 `Region`，回收旧 `Region` 全部空间；
    - `STW` 多线程。

> 追求能够应付应用的**内存分配速率**，而不是一次清理整个堆。

不会产生碎片的原因：
- 整体上是 `Mark-Compact`；
- 局部上是 `Mark-Copy`。

缺点：

- 内存占用(`Footprint`)和额外内存负载(`Overload`) 高；
- 记忆集每个 `Region` 维护一份，占整个堆容量的 `20%+`；
- 写后屏障维护卡表，写前屏障跟踪并发的指针变化。写屏障消耗资源；
    - 写前、写后要做的事情放到队列里 ，异步执行。