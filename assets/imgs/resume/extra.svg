<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentScriptType="application/ecmascript" contentStyleType="text/css" height="445px" preserveAspectRatio="none" style="width:732px;height:445px;background:#FFFFFF;" version="1.1" viewBox="0 0 732 445" width="732px" zoomAndPan="magnify"><defs><filter height="300%" id="f95cyzt9m73y2" width="300%" x="-1" y="-1"><feGaussianBlur result="blurOut" stdDeviation="2.0"/><feColorMatrix in="blurOut" result="blurOut2" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 .4 0"/><feOffset dx="4.0" dy="4.0" in="blurOut2" result="blurOut3"/><feBlend in="SourceGraphic" in2="blurOut3" mode="normal"/></filter></defs><g><rect fill="#FEFECE" filter="url(#f95cyzt9m73y2)" height="36.2969" rx="12.5" ry="12.5" style="stroke:#A80036;stroke-width:1.5;" width="106" x="10" y="203.5625"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="86" x="20" y="226.5576">explain extra</text><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="167" x="169" y="23.9951">backward index scan</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="230" x="336" y="23.9951">: 使用 descending index(降序索引)</text><path d="M116,221.7109 L126,221.7109 C141,221.7109 141,19.1484 156,19.1484 L166,19.1484 " fill="none" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="59" x="169" y="42.292">Distinct</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="205" x="228" y="42.292">: 找到第一个符合的行后就不再找</text><path d="M116,221.7109 L126,221.7109 C141,221.7109 141,37.4453 156,37.4453 L166,37.4453 " fill="none" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="60.5889"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="164" x="169" y="76.8857">FirstMatch(tbl_name)</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="112" x="337" y="76.8857">半连接找到第一个</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="462" x="169" y="93.1826">半连接是一个子查询，它主要用于去重。只返回存在内表中的外表的记录，</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="206" x="169" y="109.4795">EXSIT和IN语句组成的布尔表达式</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="125.7764"/><path d="M116,221.7109 L126,221.7109 C141,221.7109 141,88.3359 156,88.3359 L166,88.3359 " fill="none" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="144.0732"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="105" x="169" y="160.3701">Using filesort</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="358" x="278" y="160.3701">MySQL 必须执行额外的检查以找出如何按排序顺序检索行</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="551" x="169" y="176.667">找不到合适的索引来 order by。读表行来排序，如果临时结果集太大使用临时硬盘空间。</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="192.9639"/><path d="M116,221.7109 L126,221.7109 C141,221.7109 141,163.6719 156,163.6719 L166,163.6719 " fill="none" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="92" x="169" y="211.2607">Using index</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="388" x="261" y="211.2607">: 使用覆盖索引，不回表。也可以 type: index &amp; key: primary</text><path d="M116,221.7109 L126,221.7109 C141,221.7109 141,206.4141 156,206.4141 L166,206.4141 " fill="none" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="229.5576"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="170" x="169" y="245.8545">Using index condition</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="261" x="339" y="245.8545">: 索引条件下推，减少读全表行的可能性。</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="467" x="169" y="262.1514">没有 ICP: base table 遍历 index 来找行，交给 存储引擎，其在 WHERE。</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="337" x="169" y="278.4482">有 ICP: where 中部分列能通过 index 满足，存储引擎</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="294.7451"/><path d="M116,221.7109 L126,221.7109 C141,221.7109 141,257.3047 156,257.3047 L166,257.3047 " fill="none" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="313.042"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="131" x="169" y="329.3389">Using temporary</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="163" x="300" y="329.3389">: 需要创建临时表保留结果</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="260" x="169" y="345.6357">一般是 group by 和 order by 不同的字段</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="361.9326"/><path d="M116,221.7109 L126,221.7109 C141,221.7109 141,332.6406 156,332.6406 L166,332.6406 " fill="none" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="380.2295"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="100" x="169" y="396.5264">Using where</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="280" x="273" y="396.5264">限制了哪些行匹配到下张表或者传给客户端。</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="391" x="169" y="412.8232">如果 join type: [all | index], 而没有此项，就全表了，有问题。</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="0" x="173" y="429.1201"/><path d="M116,221.7109 L126,221.7109 C141,221.7109 141,399.8281 156,399.8281 L166,399.8281 " fill="none" style="stroke:#A80036;stroke-width:1.0;"/><!--MD5=[01d72c1d764c3410896847ff82069a26]
@startmindmap explain extra 脑图
* explain extra
**_ **backward index scan**: 使用 descending index(降序索引)
**_ **Distinct**: 找到第一个符合的行后就不再找
**_: 
**FirstMatch(tbl_name)** 半连接找到第一个
半连接是一个子查询，它主要用于去重。只返回存在内表中的外表的记录，
EXSIT和IN语句组成的布尔表达式
;
**_:
**Using filesort** MySQL 必须执行额外的检查以找出如何按排序顺序检索行
找不到合适的索引来 order by。读表行来排序，如果临时结果集太大使用临时硬盘空间。
;
**_ **Using index**: 使用覆盖索引，不回表。也可以 type: index & key: primary
**_: 
**Using index condition**: 索引条件下推，减少读全表行的可能性。
没有 ICP: base table 遍历 index 来找行，交给 存储引擎，其在 WHERE。
有 ICP: where 中部分列能通过 index 满足，存储引擎
;
**_:
**Using temporary**: 需要创建临时表保留结果
一般是 group by 和 order by 不同的字段
;
**_:
**Using where** 限制了哪些行匹配到下张表或者传给客户端。
如果 join type: [all | index], 而没有此项，就全表了，有问题。
;
@endmindmap

PlantUML version 1.2021.6(Fri May 14 07:09:51 UTC 2021)
(GPL source distribution)
Java Runtime: OpenJDK Runtime Environment
JVM: OpenJDK 64-Bit Server VM
Default Encoding: UTF-8
Language: en
Country: null
--></g></svg>